---
title: 归并排序
date: 2020-6-14 21:47:58
mathjax: true
tags:
	- OI
	- 基本算法
categories:
	- OI
	- 知识点
	- 排序
---
# 归并排序

**一、思想 **

* **分解**：通过二分的思想，将序列多次拆分成一个又一个的小区间。类似于线段树在build的时候会把整个序列分割成一个又一个小区间直到无法继续分割。
* **排序**：对拆分好的每一个小区间进行排序。通过局部有序然后向上合并达到全局有序。
* **合并**：把两个已经排序好的小区间合并成一个较大的小区间。向上更新区间，从小区间向上推。

**二、实现过程**

1.  **拆分与排序 **

![拆分与排序][1]

2.  **合并过程**

![合并过程][2]

<!-- more -->

**三、复杂度**

1.  **时间复杂度**：由于会有一个二分的操作，所以是有一个$ log$级别的操作。因为对每一个区间都要进行整理顺序并且合并，对每个区间的操作是$ O(len)$的时间复杂度（$len$代表区间的长度）。因为是二分的区间，所以最终时间复杂度是$O(nlogn)$。
2.  **空间复杂度**：因为需要一个新数组作为两个连续的小区间的合并区间，所以空间复杂度为$O(n)$。
3.  **算法稳定性**：因为首先需要对数组拆分，并且对拆分出来的每一个小区间都需要扫描一遍来排序。所以无论数列的顺序如何，算法的复杂度都是$O(nlogn)$。所以是稳定的排序算法。

**四、代码实现**

1.  **main函数部分**：

    ```cpp
    signed main()
    {
    	scanf("%lld",&n);
    	for (int i=1;i<=n;i++)
    		scanf("%lld",&a[i]);
    	merge_sort(1,n);//对这个数组的1到n进行排序
    	for (int i=1;i<=n;i++)
    		printf("%lld ",a[i]);
    	puts("");
    	return 0;
    }
    ```

    

2.  **拆分部分**：

    ```cpp
    if (l==r)//拆分到底的情况
        return ;
    int mid=(l+r)/2;//二分继续拆分
    merge_sort(l,mid);//左子区间
    merge_sort(mid+1,r);//右子区间
    ```

    

3.  **排序并合并部分**：

    ```cpp
    int i=l,j=mid+1,k=l;
    //i代表左区间目前扫描到的数的位置，j代表右区间目前扫描到的数的位置
    //k代表合并区间目前最后一个数在合并区间的位置，对应的是合并之后这个元素在原序列中的位置
    	while (i<=mid&&j<=r)//保证i一定在左区间并且j一定在右区间
    	{
    		if (a[i]<=a[j])//左区间的第一个数大于右区间的第一个数 
    		{
    			comb[k]=a[i];//comb代表合并在一起的区间，临时存储
    			i++;//准备扫描左区间下一个数
    			k++;//合并区间里面的元素个数加加
    		}//左区间的第一个数按顺序放在合并区间
    		else//右区间的第一个数大于左区间的第一个数 
    		{
    			comb[k]=a[j];
    			j++;
    			k++;//同上理
    		}//右区间的第一个数按顺序放在合并区间
    	}//这样操作之后左区间或者右区间有可能没被扫描完，因为i和j有一个会先到达边界
    	while (i<=mid)    
    	{
    		comb[k]=a[i];
    		i++;
    		k++; 
    	}
    	while (j<=r) 	 	   
    	{
    		comb[k]=a[j];
    		j++;
    		k++;
    	}//把这两个小区间没有分到合并区间都分过去
    ```

    

4.  **复原部分**:

    ```cpp
    for (int i=l;i<=r;i++)
    	a[i]=comb[i];//把原来的两个区间更新为现在已经找计算来的合并区间
    ```

    

5.  **完整代码**：

    ```cpp
    #include<bits/stdc++.h>
    #define int long long
    #define N 111111
    using namespace std;
    int n;
    int a[N],comb[N];
    void merge_sort(int l,int r)
    {
        if (l==r)//拆分到底的情况
        return ;
    	int mid=(l+r)/2;//二分继续拆分
    	merge_sort(l,mid);//左子区间
    	merge_sort(mid+1,r);//右子区间
    	int i=l,j=mid+1,k=l;
    	//i代表左区间目前扫描到的数的位置，j代表右区间目前扫描到的数的位置
    	//k代表合并区间目前最后一个数在合并区间的位置，对应的是合并之后这个元素在原序列中的位置
    	while (i<=mid&&j<=r)//保证i一定在左区间并且j一定在右区间
    	{
    		if (a[i]<=a[j])//左区间的第一个数大于右区间的第一个数 
    		{
    			comb[k]=a[i];//comb代表合并在一起的区间，临时存储
    			i++;//准备扫描左区间下一个数
    			k++;//合并区间里面的元素个数加加
    		}//左区间的第一个数按顺序放在合并区间
    		else//右区间的第一个数大于左区间的第一个数 
    		{
    			comb[k]=a[j];
    			j++;
    			k++;//同上理
    		}//右区间的第一个数按顺序放在合并区间
    	}//这样操作之后左区间或者右区间有可能没被扫描完，因为i和j有一个会先到达边界
    	while (i<=mid)    
    	{
    		comb[k]=a[i];
    		i++;
    		k++; 
    	}
    	while (j<=r) 	 	   
    	{
    		comb[k]=a[j];
    		j++;
    		k++;
    	}//把这两个小区间没有分到合并区间都分过去
    	for (int i=l;i<=r;i++)	 	  
    		a[i]=comb[i];//把原来的两个区间更新为现在已经找计算来的合并区间
    }
    signed main()
    {
    	scanf("%lld",&n);
    	for (int i=1;i<=n;i++)
    		scanf("%lld",&a[i]);
    	merge_sort(1,n);
    	for (int i=1;i<=n;i++)
    		printf("%lld ",a[i]);
    	puts("");
    	return 0;
    }
    ```

**五、应用：求逆序对**


>   设A为一个有n个[数字](https://zh.wikipedia.org/wiki/数字)的[有序集](https://zh.wikipedia.org/w/index.php?title=有序集&action=edit&redlink=1)（n>1），其中所有数字各不相同。如果存在正整数i, j使得1 ≤ i ＜ j ≤ n而且A[i] ＞ A[j]，则<A[i], A[j]>这一个[有序对](https://zh.wikipedia.org/wiki/有序对)称为A的一个**逆序对**，也称作逆序。逆序对的数量称作逆序数。---摘自[维基百科][3]

例如，一个数列$ 1,3,2,4,5$,那么其中$3,2$是一个逆序对。这个数列中，逆序对的个数为1.

那么我们首先想到求逆序对的方法一定是暴力枚举两个数，看他们是否成逆序对。但这样的时间复杂度太高了，为$O(n)$。

那逆序对和归并排序有什么关系呢？

我们再来温习一下归并排序合并的过程。

首先，对于两个小区间，要将他们合并成一个大区间，必然会在两个小区间从头开始扫描过去，例如下图：

![逆序对-1][4]

这个图中，我们会先把$1$放在合并区间中，再把$2$放入区间中。然后我们会发现，右区间的$1$与左区间的四个数都构成逆序对。

继续扫描，将2放入区间中，$2$与左区间的四个数也构成逆序对。

![逆序对-2][5]

$3$也是如此。但到了8的时候，就会发现，此时不能将8放入区间了，并且8也不于左区间的所有数构成逆序对。

![逆序对-3][6]

继续操作，直到9的时候，会发现此时$8$与左区间剩余的$9$成逆序对，并且该把$8$放入区间。

由此我们可以得到规律：

**在归并排序合并区间的时候，若该将右区间的某个数放入合并区间时，左区间剩余的数都与这个数构成1逆序对**。

所以我们假设左区间目前剩余的第一个数的下标为$i$，左区间的末端下标为$mid$，那么每当一个右区间的数放入左区间时，逆序对的个数就增加$mid-i+1$。

所以我们需要在原来归并排序的代码上改动如下：

```cpp
while (i<=mid&&j<=r)//保证i一定在左区间并且j一定在右区间
{
    if (a[i]<=a[j])//左区间的第一个数大于右区间的第一个数 
    {
        comb[k]=a[i];//comb代表合并在一起的区间，临时存储
        i++;//准备扫描左区间下一个数
        k++;//合并区间里面的元素个数加加
    }//左区间的第一个数按顺序放在合并区间
    else//右区间的第一个数大于左区间的第一个数 
    {
        comb[k]=a[j];
        j++;
        k++;//同上理
        cnt+=(mid-i+1);//逆序对的个数增加
    }//右区间的第一个数按顺序放在合并区间
}//这样操作之后左区间或者右区间有可能没被扫描完，因为i和j有一个会先到达边界
```

完整代码如下：

```cpp
#include<bits/stdc++.h>
#define int long long
#define N 111111
using namespace std;
int n,cnt=0;
int a[N],comb[N];
void merge_sort(int l,int r)
{
    if (l==r)//拆分到底的情况
    return ;
	int mid=(l+r)/2;//二分继续拆分
	merge_sort(l,mid);//左子区间
	merge_sort(mid+1,r);//右子区间
	int i=l,j=mid+1,k=l;
	//i代表左区间目前扫描到的数的位置，j代表右区间目前扫描到的数的位置
	//k代表合并区间目前最后一个数在合并区间的位置，对应的是合并之后这个元素在原序列中的位置
	while (i<=mid&&j<=r)//保证i一定在左区间并且j一定在右区间
	{
		if (a[i]<=a[j])//左区间的第一个数大于右区间的第一个数 
		{
			comb[k]=a[i];//comb代表合并在一起的区间，临时存储
			i++;//准备扫描左区间下一个数
			k++;//合并区间里面的元素个数加加
		}//左区间的第一个数按顺序放在合并区间
		else//右区间的第一个数大于左区间的第一个数 
		{
			comb[k]=a[j];
			j++;
			k++;//同上理
			cnt+=(mid-i+1);
		}//右区间的第一个数按顺序放在合并区间
	}//这样操作之后左区间或者右区间有可能没被扫描完，因为i和j有一个会先到达边界
	while (i<=mid)    
	{
		comb[k]=a[i];
		i++;
		k++; 
	}
	while (j<=r) 	 	   
	{
		comb[k]=a[j];
		j++;
		k++;
	}//把这两个小区间没有分到合并区间都分过去
	for (int i=l;i<=r;i++)	 	  
		a[i]=comb[i];//把原来的两个区间更新为现在已经找计算来的合并区间
}
signed main()
{
	scanf("%lld",&n);
	for (int i=1;i<=n;i++)
		scanf("%lld",&a[i]);
	merge_sort(1,n);
	for (int i=1;i<=n;i++)
		printf("%lld ",a[i]);
	puts("");
	printf("%lld\n",cnt);
	return 0;
}
```


  [1]: 1.png
  [2]: 2.png
  [3]: https://zh.wikipedia.org/wiki/%E9%80%86%E5%BA%8F%E5%AF%B9
  [4]: 4.png
  [5]: 5.png
  [6]: 6.png